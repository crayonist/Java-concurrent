### **线程一些常见的方法**
---

- join()：等待线程执行终止
    + 场景：多个线程加载资源，需要等待多个线程全部加载完毕再汇总处理；
    + 调用join()后同样会被阻塞；
- sleep()：线程睡眠（**线程在睡眠时拥有的监视器资源不会被释放**）
    + 当一个运行状态的线程调用了Thread.sleep();调用线程会暂时让出指定时间的执行权，这段时间不参与CPU的调度，但并没有释放其所持有的监视器锁；
    + 休眠结束后，该线程重新进入就绪状态，等待CPU资源调度；
    + 如果在休眠期间其他线程调用了该线程的interrupt()中断了该线程，则该线程会在调用sleep的地方抛出InterruptException异常而返回；
- yield()：让出CPU执行权
    + 当一个线程调用yield()方法时，暗示线程调度器当前线程请求让出自己的CPU的使用，但是线程调度器可以无条件忽略这个暗示；
    + 调用yield后线程处于就绪状态，线程调度器会从线程就绪队列里面获取一个线程优先级最高的线程，当然也有可能会调度到
      刚刚让出CPU的那个线程来获取CPU执行权。

- sleep()与yield()的区别：
    + 当线程调用sleep()时调用线程会被阻塞挂起指定的时间，在这期间线程调度器不会去调度该线程；
    + 而调用yield()时，线程只是让出自己剩余的时间片，并没有被阻塞挂起，而是处于就绪状态，线程调度器下一次调度
      时就有可能调度到当前线程执行。
  