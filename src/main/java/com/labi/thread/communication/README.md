### **线程的通知与等待**
---
- wait(): 

    1 调用wait()的线程要先获取该对象的监视器锁，否则会抛出异常
    ```
    java.lang.IllegalMonitorStateException
    ```
    获取对象监视锁：<br>
    
    (1) 执行该sychronized同步代码块时，使用该共享对象作为锁参数
    ```
      sychronized(共享变量) {
        // ...
      }
    ```
    (2) 调用该共享变量的方法，并且该方法使用了sychronized修饰
    ```
      sychronized void foo(int a, int b) {
        // ...
      }
    ```
    
    2 wait():线程挂起,并释放通过同步块获取的queue上的锁<br>
    在调用wait函数线程阻塞挂起后，以下情况会使该线程重新进入就绪状态：
    - 其他线程调用了该共享对象的notify()或notifyAll()方法来唤醒；
    - 其他线程调用了该线程的interrupt()中断方法，则该线程会抛出中断异常java.lang.InterruptedException
    
    注意：当前线程调用共享变量的wait()后只会释放当前共享变量上的锁，如果当前线程还持有其他共享变量的锁，这些锁是不会被释放的。
    
    
- notify():
    
    1 notify()：一个线程调用共享变量的notify()后，会唤醒一个在共享变量上调用wait()系列方法后挂起的线程。<br>
    需要注意的几个点：
    + 一个共享变量上可能会有多个线程在等待，具体唤醒哪个等待的线
      程是随机的。 
    + 被唤醒的线程不能马上从 wait()返回并继续执行，它必须在获取了共享对
      象的监视器锁后才可以返回，也就是唤醒它的线程释放了共享变量上的监视器锁后，被唤
      醒的线程也不一定会获取到共享对象的监视器锁，这是因为该线程还需要和其他线程一起
      竞争该锁，只有该线程竞争到了共享变量的监视器锁后才可继续执行。
    + 同wait()，只有当前线程获取到了共享变量的监视器锁后，才可以调用共
      享变量的notify()，否则会抛出 IllegalMonitorStateException 异常。
    2 notifyAll()：唤醒所有wait()等待线程
- 虚假唤醒：
    + 一个线程在wait阻塞等待的状态下，除了其他线程调用notify、notifyAll，也可能会变为运行状态，称为虚假唤醒。
